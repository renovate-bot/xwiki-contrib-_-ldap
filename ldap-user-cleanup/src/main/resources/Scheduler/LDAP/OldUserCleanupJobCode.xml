<?xml version="1.0" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.6" reference="Scheduler.LDAP.OldUserCleanupJobCode" locale="">
  <web>Scheduler.LDAP</web>
  <name>OldUserCleanupJobCode</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1759822355000</creationDate>
  <parent>Main.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <originalMetadataAuthor>XWiki.Admin</originalMetadataAuthor>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1761224670000</date>
  <contentUpdateDate>1761223971000</contentUpdateDate>
  <version>1.1</version>
  <title>Old User Cleanup Job Code</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>plain/1.0</syntaxId>
  <hidden>true</hidden>
  <content>import javax.inject.Provider;
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.xwiki.contrib.ldap.XWikiLDAPUtils;
import org.xwiki.contrib.ldap.XWikiLDAPConfig;
import org.xwiki.contrib.ldap.XWikiLDAPConnection;
import org.xwiki.component.util.DefaultParameterizedType;
import org.xwiki.script.service.ScriptServiceManager
import org.xwiki.security.authorization.Right;
import com.xpn.xwiki.doc.XWikiAttachment;
import com.xpn.xwiki.web.Utils;
import com.xpn.xwiki.XWikiException;

class LDAPOldUserCleanup {

  def logger
  def xcontext
  def xwiki
  def config
  def dryRun = true
  def hasMetaAuthors = false

  def services

  // a lengthy helper to replace the user references in one (sub-)wiki
  def adjustDocumentAuthorAndComments(userReference, replacementUserRef) {

    def replaceAuthor = (config.getIntValue('replaceAuthor') == 1)
    def replaceCreator = (config.getIntValue('replaceCreator') == 1)
    def replaceContentAuthor = (config.getIntValue('replaceContentAuthor') == 1)
    def replaceCommentAuthor = (config.getIntValue('replaceCommentAuthor') == 1)

    def userName = services.model.serialize(userReference, 'compactwiki')
    def fullUserName = services.model.serialize(userReference, 'default')
    def replacementUserName = (replacementUserRef == null) ? "XWiki.XWikiGuest" : services.model.serialize(replacementUserRef, 'compactwiki')
    def replacementUserAsUserRef = null
    def userAsUserReference = null

    if (hasMetaAuthors) {
      replacementUserAsUserRef = services.user.getGuestUserReference() 
      if (replacementUserRef != null) {
        if (replacementUserName == 'XWiki.superadmin') {
          replacementUserAsUserRef = services.user.getSuperAdminUserReference()
        } else {
          replacementUserAsUserRef = new org.xwiki.user.internal.document.DocumentUserReference(replacementUserRef, xcontext.isMainWiki())
        }
      }
      userAsUserReference = new org.xwiki.user.internal.document.DocumentUserReference(userReference, xcontext.isMainWiki())
    }

    if (replaceAuthor || replaceCreator || replaceContentAuthor) {

      def arguments = ['user' : userName, 'fulluser' : fullUserName]
      def queryString = 'WHERE '
      def fromClause = ''
      def queryStringParts = []
      if (replaceAuthor) {
        queryStringParts.add('(doc.author = :user OR doc.author = :fulluser)')
        if (hasMetaAuthors) {
          queryStringParts.add('(doc.originalMetadataAuthorReference = :user OR doc.originalMetadataAuthorReference = :fulluser)')
        }
      }
      if (replaceCreator) {
        queryStringParts.add('(doc.creator = :user OR doc.creator = :fulluser)')
      }
      if (replaceContentAuthor) {
        queryStringParts.add('(doc.contentAuthor = :user OR doc.contentAuthor = :fulluser)')
      }
      queryString += String.join(" OR ", queryStringParts)
      queryString = fromClause + queryString
      logger.info("&gt;&gt;&gt;&gt; run database query [${queryString}] with values [${arguments}]")

      services.query.xwql(queryString).bindValues(arguments).addFilter('language').execute().each( { someDocRes -&gt;
        def someDocName = someDocRes[0]
        String someDocLang = someDocRes[1]
        if (someDocLang == null) { someDocLang = '' }
        if (someDocLang != '') {
          someDocName = someDocName +' (lang='+someDocLang+')'
        }
        logger.debug("found document to check [$someDocName]")
        def someDoc = xwiki.getDocument(someDocRes[0], xcontext)
        if (someDocLang != '') {
          def someTranslation = someDoc.getTranslatedDocument(someDocLang, xcontext)
          if (someTranslation != null &amp;&amp; !someTranslation.isNew()) {
            logger.trace('actually use translation [{}] aka [{}]', someTranslation, someTranslation.documentReferenceWithLocale)
            someDoc = someTranslation
          } else {
            logger.trace('actually use default language for [{}]', someDoc.documentReferenceWithLocale)
          }
        }
        if (someDoc.isNew()) {
          logger.warn('query found non-existing document [{}] aka [{}]', someDocName, someDoc.getDocumentReferenceWithLocale())
          return;
        }
        def needsSave = false
        if (replaceCreator) {
          if (userReference.equals(someDoc.getCreatorReference())) {
            logger.trace("&gt;&gt;&gt; document creator for [$someDocName]")
            if (!dryRun) someDoc.setCreatorReference(replacementUserRef)
            needsSave = true
          } else {
            logger.trace("&gt;&gt;&gt; $userReference not document creator for [$someDocName], but ${someDoc.creator}")
          }
        }
        if (replaceAuthor) {
          if (userReference.equals(someDoc.getAuthorReference())) {
            logger.trace("&gt;&gt;&gt; document author for [$someDocName]")
            if (!dryRun) someDoc.setAuthorReference(replacementUserRef)
            needsSave = true
          } else {
            logger.trace("&gt;&gt;&gt; $userReference not document author for [$someDocName], but ${someDoc.author}")
          }
          if (hasMetaAuthors) {
            def metaAuthor = someDoc.getAuthors().getOriginalMetadataAuthor()
            if (userAsUserReference.equals(metaAuthor)) {
              logger.trace("&gt;&gt;&gt; set meta author for [$someDocName]")
              if (!dryRun) someDoc.getAuthors().setOriginalMetadataAuthor(replacementUserAsUserRef)
              needsSave = true
            } else {
              logger.trace("&gt;&gt;&gt; $userReference not metadata author for [$someDocName], but ${metaAuthor}")
            }
          }
        }
        if (replaceContentAuthor) {
          if (userReference.equals(someDoc.getContentAuthorReference())) {
            logger.trace("&gt;&gt;&gt; content author for [$someDocName]")
            if (!dryRun) someDoc.setContentAuthorReference(replacementUserRef)
            needsSave = true
          } else {
            logger.trace("&gt;&gt;&gt; $userReference not content author for [$someDocName], but ${someDoc.contentAuthor}")
          }
        }

        if (needsSave) {
          if (dryRun) {
            logger.debug("would update document [${someDocName}] with replacement user [${replacementUserRef}]")
          } else {
            logger.debug("save document [${someDocName}] with replacement user [${replacementUserRef}]")
            // we need to save without a new version, or the "content author" will be overwritten
            someDoc.setMetaDataDirty(false)
            someDoc.setContentDirty(false)
            xwiki.saveDocument(someDoc, "Replaced user [${userName}] with user [${replacementUserName}]", true, xcontext)
            // xwiki.getHibernateStore().saveXWikiDoc(someDoc, xcontext)
          }
        }

      })
    }

    // we need to handle comments separately; if we include them in the above query we'd only find document with at least one comment
    // on the other hand comments are always language independent, making the check easier
    // because of LDAP-116 we need to switch to HQL however
    if (replaceCommentAuthor) {
      def queryStringAuthor = "SELECT doc.fullName from XWikiDocument as doc, BaseObject as comment, LargeStringProperty as author"
      queryStringAuthor += " WHERE doc.fullName = comment.name AND comment.className = 'XWiki.XWikiComments'"
      queryStringAuthor += " AND (author.id.id=comment.id and author.id.name='author') AND (str(author.value) = :user)"
      def arguments = ['user' : userName]
      services.query.hql(queryStringAuthor).bindValues(arguments).addFilter('unique').execute().each( { someDocName -&gt;

        logger.debug("found document with comments to check [$someDocName]")
        def someDoc = xwiki.getDocument(someDocName, xcontext)
        def needsSave = false
        someDoc.getObjects('XWiki.XWikiComments').each( { comment -&gt;
          if (comment != null &amp;&amp; comment.getStringValue('author') == userName) {
            logger.trace("&gt;&gt;&gt; comment author for [$comment.reference]")
            if (!dryRun) comment.set('author', replacementUserName, xcontext)
            needsSave = true
          }
        })
        if (needsSave) {
          if (dryRun) {
            logger.debug("would save comments in document [$someDocName] with replacement user [${replacementUserRef}]")
          } else {
            logger.debug("save comments in document [$someDocName] with replacement user [${replacementUserRef}]")
            xwiki.saveDocument(someDoc, "Replaced user [${userName}] with user [${replacementUserName}]", true, xcontext)
          }
        }

      })
    }
  }

  def disableUser(userName) {
    try {
      def userRef = services.model.resolveDocument(userName)
      def user = xwiki.getUser(userRef, xcontext);
      if (!user.isDisabled()) {
        if (dryRun) {
          logger.info("Would disable the user [${userRef}]")
        } else {
          logger.info("Disabling the user [${userRef}]")
          user.setDisabledStatus(true);
        }
      } else {
        logger.debug("User [${userRef}] is already disabled")
      }
    } catch (Exception e) {
      if (dryRun) {
        logger.warn("Exception while test disabling [${userName}].", e)
      } else {
        logger.warn("Exception while disabling [${userName}].", e)
      }
    }
  }

  // adjust references to replacement user and remove user
  def deleteUser(userName) {
    try {
      def replacementUserName
      if (services.security.authorization.hasAccess(Right.PROGRAM,
                                                    xwiki.getDocument(userName, xcontext).getDocumentReference(),
                                                    xwiki.getDocument('XWiki.XWikiPreferences', xcontext).getDocumentReference())) {
        replacementUserName = config.getStringValue('replacementAdmin')
        logger.debug('user [{}] has programming rights, replace by [{}]', userName, replacementUserName)
      } else {
        replacementUserName = config.getStringValue('replacementUser')
        logger.debug('user [{}] has no programming rights, replace by [{}]', userName, replacementUserName)
      }

      def userRef = services.model.resolveDocument(userName)
      def replacementUserRef = services.model.resolveDocument(replacementUserName)
      if (replacementUserName == "XWiki.XWikiGuest") {
        replacementUserRef = null
      }

      if (xcontext.isMainWiki()) {
        def mainWikiId = xcontext.getWikiId()
        services.wiki.allIds.each({ wikiId -&gt;
          logger.debug("check for documents in ${wikiId}")
          try {
            xcontext.setWikiId(wikiId)
            adjustDocumentAuthorAndComments(userRef, replacementUserRef)
          } finally {
            xcontext.setWikiId(mainWikiId)
          }
        })
      } else {
        // just use the current wiki
        adjustDocumentAuthorAndComments(userRef, replacementUserRef)
      }

      if (dryRun) {
        logger.info("would delete user [${userRef}]")
      } else {
        logger.info("deleting the user [${userRef}]")
        xwiki.deleteDocument(xwiki.getDocument(userRef, xcontext), xcontext)
      }
    } catch (Exception e) {
      if (dryRun) {
        logger.warn("Exception while test deleting [${userName}].", e)
      } else {
        logger.warn("Exception while deleting [${userName}].", e)
      }
    }
  }

  def getOrDefault(object, attribute, defaultValue) {
    def value = object.getStringValue(attribute)
    if (value == null || "".equals(value)) {
      return defaultValue
    }
    return value
  }

  def shouldDelete(userDn, userId, ldapConfig, config, connector, ldapUtils, it, logger) {
    def userObj = [];
    if (userDn == null || userDn.isEmpty()) {
      logger.debug("DN of user [{}] is empty.", it);
      // Setting the userDn to null in case it is an empty string, otherwise the removeExcludedGroups checks would fail.
      userDn = null;
    } else {
      logger.debug("lookup by DN for [{}]", userDn);
      // here we get back a null on ldap server errors, including if there is no such user at the given dn.
      // (as it is done via DN lookup, a missing object at this dn counts as an error
      // and is not distinguisable from any other server error)
      // this might happen, if the user dn got renamed (i.e. moved to another OU)
      // or simply deleted.
      userObj = connector.searchLDAP(userDn, '(objectClass=*)', null, 0);
    }
    if (userObj == null || userObj.isEmpty()) {
      // second try: find it by its uid
      // this also returns null on failure, but it returns an empty result if the user is not found,
      // allowing to distinguish between cases of ldap server error and removed user
      def searchQuery = ldapConfig.getLDAPParam("ldap_user_search_fmt", "({0}={1})");
      logger.debug("DN lookup failed; search instead for uid=[{}] with [{}]", userId, searchQuery);
      ldapUtils.setUserSearchFormatString(searchQuery);
      userObj = ldapUtils.searchUserAttributesByUid(userId, null);
    }

    if (userObj == null) {
      logger.warn("There was an error when trying to search for the user [{}] with dn [{}]. The user won't be disabled/deleted.", userId, userDn);
      return false;
    }
    else if (userObj.isEmpty()) {
      return true;
    }

    if (config.getIntValue('removeExcludedGroups', 0) != 0) {
      def includedGroups = ldapConfig.getLDAPParam("ldap_user_group", "");
      logger.debug("Checking whether the user is in the included groups [{}].", includedGroups);
      if (!includedGroups.isEmpty() &amp;&amp; ldapUtils.isInGroup(userId, null, includedGroups, xcontext) == null) {
        logger.debug("The user is not part of the included groups.");
        return true;
      }
      def excludedGroups = ldapConfig.getLDAPParam("ldap_exclude_group", "");
      logger.debug("Checking whether the user is in the excluded groups [{}].", excludedGroups);
      if (!excludedGroups.isEmpty() &amp;&amp; ldapUtils.isInGroup(userId, null, excludedGroups, xcontext) != null) {
        logger.debug("The user is part of the excluded groups.");
        return true;
      }
    }
    def activeAttribute = getOrDefault(config, 'activeAttribute', '');
    def inactiveValue = getOrDefault(config, 'inactiveValue', '');
    logger.debug("Checking if the user is disabled in LDAP. Must have attribute [{}={}].", activeAttribute, inactiveValue);
    if (userObj.stream().anyMatch{it.name.equals(activeAttribute) &amp;&amp; it.value.equals(inactiveValue)}) {
      logger.debug("The user is disabled in the LDAP server.");
      return true;
    }

    return false;
  }

  def cleanup(xcontext) {
    this.xcontext = xcontext
    this.xwiki = xcontext.getWiki()
    this.services = Utils.getComponent(ScriptServiceManager.class)
    this.logger = LoggerFactory.getLogger('org.xwiki.contrib.ldap.scheduler.OldUserCleanup')

    // XXX why fetch doc again? api class vs non api class?
    def document = xcontext.getDoc()
    def doc = xwiki.getDocument(document.getFullName(), xcontext)
    def thisDoc = xwiki.getDocument('Scheduler.LDAP.OldUserCleanupJobCode', xcontext)

    logger.info('running scheduler job {} in version [{}]', doc.getTitle(), doc.getVersion())
    logger.info('code is in version [{}]', thisDoc.getVersion())
    logger.warn('running scheduler doc {} aka document [{}] with name [{}]', doc.getClass(), document.getClass(), doc.getFullName())
    logger.warn('xcontext is [{}] and xwiki [{}]', xcontext.getClass(), xwiki.getClass())

    this.config = doc.getXObject(doc.getDocumentReference())
    this.hasMetaAuthors = doc.metaClass.respondsTo(doc, 'getAuthors')

    if (config == null) {
      logger.info('Could not run user cleanup; configuration is missing')
    } else {

      def user
      def password
      def shouldDisable

      this.dryRun = (config.getIntValue('dryRun') != 0)
      try {
        def setupOk = false;

        def ldapConfigProvider = null;
        try {
           // why does this fail?
           ldapConfigProvider = Utils.getComponent(new DefaultParameterizedType(null, Provider.class, XWikiLDAPConfig.class))
        } catch (Exception e) {
          // skip
        }
        XWikiLDAPConfig ldapConfig = null;
        if (ldapConfigProvider != null &amp;&amp; ldapConfigProvider.get() != null) {
          logger.debug('Using ldap configuration coming from a provider.');
          ldapConfig = ldapConfigProvider.get();
        } else {
          logger.debug('Using standard ldap configuration.')
          ldapConfig = new XWikiLDAPConfig(null);
        }

        user = getOrDefault(config, 'ldapBindDn', ldapConfig.getLDAPParam("ldap_bind_DN",""))
        password = getOrDefault(config, 'ldapBindPass', ldapConfig.getLDAPParam("ldap_bind_pass",""))
        logger.debug('Using the following user to connect to ldap [{}].', user);
        shouldDisable = (config.getIntValue('shouldDisable', 0) != 0)
        setupOk = !(!user || !password)

        if (!setupOk) {
          logger.warn("cannot remove users without login data for a service user")
        } else {

          logger.info('Starting cleanup of removed users');

          XWikiLDAPConnection connector = new XWikiLDAPConnection(ldapConfig);
          connector.open(user, password, xcontext);

          XWikiLDAPUtils ldapUtils = new XWikiLDAPUtils(connector, ldapConfig)
          ldapUtils.setBaseDN(ldapConfig.getLDAPParam('ldap_base_DN', ''))
          ldapUtils.setUidAttributeName(ldapConfig.getLDAPParam('ldap_UID_attr', 'cn'));
          ldapUtils.setUserSearchFormatString(ldapConfig.getLDAPParam('ldap_user_search_fmt', '({0}={1})'));
          try {
            services.query.xwql("from doc.object(XWiki.LDAPProfileClass) as ldap_profile").execute().each( {
              // def userProfileRef = services.model.resolveDocument(it, 'currentwiki')
              def userProfileDoc = xwiki.getDocument(it, xcontext)
              logger.debug('check user [{}]', userProfileDoc.getDocumentReference().getName())
              def userDn = userProfileDoc.getObject('XWiki.LDAPProfileClass').getStringValue('dn')
              def userId = userProfileDoc.getObject('XWiki.LDAPProfileClass').getStringValue('uid')
              if (shouldDelete(userDn, userId, ldapConfig, config, connector, ldapUtils, it, logger)) {
                if (dryRun) {
                  if (shouldDisable) {
                    logger.info("the user [{}] is no longer in LDAP; we would disable them", it)
                  } else {
                    logger.info("the user [{}] is no longer in LDAP; we would delete them", it)
                  }
                } else {
                  if (shouldDisable) {
                    logger.info("the user [{}] is no longer in LDAP; we are going to disable them", it)
                  } else {
                    logger.info("the user [{}] is no longer in LDAP; we are going to delete them", it)
                  }
                }
                if (shouldDisable) {
                  disableUser(it)
                } else {
                  deleteUser(it)
                }
              } else {
                logger.debug('Skipping user [{}].', it);
              }
            })
          } finally {
            connector.close();
          }
        }
      } catch (Exception e) {
        logger.error('Error in user cleanup', e);
      }
    }
    logger.info('Finished old user cleanup update')
  }

}</content>
</xwikidoc>
